常见的时间复杂度量级有：

	常数阶O(1)

	对数阶O(logN)

	线性阶O(n)

	线性对数阶O(nlogN)

	平方阶O(n²)

	立方阶O(n³)

	K次方阶O(n^k)

	指数阶(2^n)

	上面从上至下依次的时间复杂度越来越大，执行的效率越来越低。

/**
 * 常数阶O(1)
 * 代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。
 */
	let i = 1;
	let j = 2;
	++i;
	j++;
	let m = i + j;

/**
 * 对数阶O(logN)
 * 在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。我们试着求解一下，假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2^n 也就是说当循环 log2^n 次以后，这个代码就结束了
 */
	let i = 1;
	let n = 10;
	while(i<n){
		i = i * 2;
	}

/**
 * 线性阶O(n)
 * for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度
 */
	for(i=1; i<=n; ++i){
	   j = i;
	   j++;
	}

/**
 * 线性对数阶O(nlogN)
 * 线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN)
 */
	for(m=1; m<n; m++){
		let i = 1;
		while(i<n){
			i = i * 2;
		}
	}

/**
 * 平方阶O(n²)
 * 如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²)
 */
	for(x=1; i<=n; x++){
	   for(i=1; i<=n; i++){
		   j = i;
		   j++;
		}
	}

/**
 * 立方阶O(n³)/K次方阶O(n^k)
 * 相当于3次循环/k次循环
 */

