/*简介*/
如今，功能丰富，动态ui的复杂web应用程序被认为是理所当然。这并不奇怪——互联网自诞生以来，已经走过了漫长的道路

最初，互联网并不是为了支持这种动态和复杂的web应用程序而构建的。它被认为是HTML页面的集合，相互链接行程一个包含信息的"web"概念。一切都是围绕HTTP的所谓"请求/相应"范式构建的。客户端加载一个页面，然后在用户单击并导航到下一个页面之前什么都不会发生

大约在2005年，AJAX被引入，很多人开始探索在客户端和服务器之间建立双向连接的可能性。尽管如此，所有HTTP通信都由客户端引导，客户端需要用户交互或定期轮询以从服务器加载新数据

/*然HTPP变成"双向"交互*/
让服务器能够"主动"向客户机发送数据的技术已经出现了相当长的时间。例如"Push"和"Comet"

最行间的一种黑客攻击方法是让服务器产生一种需要向客户端发送数据的错觉，这称为"长轮询"。通过长轮询，客户端打开与服务器的HTTP连接，使其保持在打开状态，直到发送相应位置。每当服务器有新数据需要发送时，就会作为响应发送

看一个简单的长轮询代码片段：

(function(){
    setTimeout(function(){
        $.ajax({
            url: 'https://api.example.com/endpoint',
            success: function(data){
                //TODO
                poll();
            },
            dataType: 'json'
        })
    }, 10000)
})()

这基本上是一个自执行函数，第一次立即运行时，它设置了10秒间隔，在对服务器的每个异步AJAX调用之后，回调将再次调用AJAX

其他技术涉及Flash或XHR multipart request和所谓的htmlfiles

但是，所有这些工作区都有一个相同的问题：它们都带着HTTP的开销，这使得塔门不适合于低延迟应用程序。想想浏览器中的多人第一人称涉及游戏或任何其他带有实时组件的在线游戏

/*WebSocket的引入*/
WebSocket规范定义了在web浏览器和服务器之间建立"套接字"链接的API。简单地说：客户机和服务器之间存在长久连接，双方可以随时开始发送数据

客户端通过WebSocket握手郭晨建立WebSocket连接。这个过程从客户机向服务器发送一个常规HTTP请求开始买这个请求中包含一个升级头，它通知服务器客户机希望建立一个WebSocket连接。

客户端建立WebSocket连接方式如下
var socket = new WebSocket('ws://websocket.example.com')
//WebSocket url使用ws方案。还有wss用于安全的WebSocket连接，相当于HTTPS

这个方案只是打开websocket.example.com的WebSocket连接的开始

下面是一个初始请求头的一个简化实例：

    (image/初始请求头简化示例.png)

如果服务器支持WebSocket协议，它将同意升级，并通过响应中的升级头进行通信

Node.js的实现方式:

    (image/NodeJs实现方式.png)

建立连接后，服务器通过升级头部中内容进行响应：

    (image/服务器响应.png)

一旦建立连接，open事件将在客户端WebSocket实例上被触发：

var socket = new WebSocket('ws://websocket.example.com');

socket.open = function(event){
    console.info('WebSocket is connected');
}

现在握手已经完成，初始HTTP连接将被使用相同底层TCP/IP连接的WebSocket连接替换。此时，双方都可以开始发送数据

/*帧协议*/
使用WebSocket，可以传输任意数量的数据，而不会产生与传统HTTP请求相关的开销。数据作为消息通过WebSocket传输，每个消息由一个或多个帧组成，其中包含正在发送的数据（有效负载）。为了确保消息在到底客户端时能够正确地重构，每一帧都以负载的4-12字节数据作为前缀，使用这种基于帧的消息传递系统有助于减少传输的非有效负载数据量，从而大大减少延迟

值得注意的是，只有在接收到所有帧并重构了原始消息负载之后，客户机才会受到关于新消息的通知

帧协议，是RFC为我们提供的：
    在RFC指定的WebSocket版本中，每个包前面只有一个报头。然而，这是一个相当复杂的报头，以下是它的构建模块
    
    (image/WebSocket每个包前报头.png)

    "FIN": 1bit，表示是消息额最后一帧，如果消息只有一帧那么第一帧也就是最后一帧，FireFox在32K之后创建了第二个帧
    
    "RSV1,RSV2,RSV3": 每个1bit，必须是0，除非扩展定义为非0。如果接受到的是非零值但是扩展没有定义，则需要关闭连接

    "opcode": 4bit，解释Payload数据，规定有以下不同的状态，如果是未知的，接收方必须马上关闭连接。状态如下
        0x00: 附加数据帧
        0x01: 文本数据帧
        0x02: 二进制数据帧
        0x3-7: 保留为之后非控制帧使用
        0x8: 关闭连接帧
        0x9: ping
        0xA: pong
        0xB-F: 保留为后面的控制帧使用

    "Mask": 1bit，掩码，定义payload数据是否进行了掩码处理，如果是1表示进行了掩码处理
        
    "Masking-key": 域的数据即是掩码密钥，用于解码PayloadData。客户端发出的数据帧需要进行掩码处理，所以此位是1

    "Payload_len": 7位，7+16位，7+64位，payload数据的长度，如果是0-125，就是真实的payload长度，如果是126，那么接着后面的2个字节对应的16位无符号整数就是payload数据长度；如果是126，那么接着后面的8个字节对应的64位无符号整数就是payload数据的长度
    
    "Masking-key"：0到4字节，如果MASK位设为1择优4个字节的掩码解密密钥，否则就没有

    "Payload data"：任意长度数据。包含有扩展定义数据和应用数据，如果没有定义扩展则没有此项，仅含有应用数据
    
/*帧数据*/
如上所述，数据可以被分割成多个帧。传输数据的第一帧有一个操作码，表示正在传输什么类型的数据。这是必要的，因为javascript在开始规范时几乎不存在对二进制数据的支持。0x01表示utf-8编码的文本数据，0x02是二进制数据。大多数人会发送JSON，在这种情况下，你可能要选择文本操作码。当你发送二进制数据时，它将在浏览器特定的Blob中表示

通过WebSocket发送数据的API非常简单：

var socket = new WebSocket('ws://websocket.example.com');

socket.onopen = function(){
    socket.send('some message')
}

当WebSocket接收数据时（在客户端），会触发一个消息事件。此事件包括一个名为data的属性，可用于访问消息的内容

socket.onmessage = function(event){
    var message = event.data;
    console.info(message)
}


/*消息分片*/
有效负载数据可以分成多个单独的帧。接收端应该对它们进行缓冲，知道设置好fin位。因此，可以将字符串"Hello World"发送到11个包汇总，每个包的长度为6（报头长度）+1字节。控制包不允许分片。但是，规范希望能够处理交错的控制帧。这是TCP包以任意顺序到达的情况

连接帧的逻辑大致如下：
    1.接收第一帧
    2.记住操作码
    3.将帧有效负载连接在一起，知道fin位被设置
    4.断言每个包的操作码是0
    
分片的目的是发送长度未知的消息。如果不分片发送，即一帧，就需要缓存整个消息，计算其长度，构建frame并发送；使用分片的话，可使用一个大小合适的buffer，用消息内容填充buffer，填满即发送出去

/*跳动检测*/
主要目的是保障客户端WebSocket与服务端连接状态，该程序有心跳检测及自动重连机制，当网络断开或者后端服务问题造成客户端WebSocket断开，程序会自动尝试重新连接直到再次连接成功

在使用原生WebSocket的时候，如果设备网络断开，不会触发任何函数，前端程序无法得知当前连接已经断开。这个时候如果调用"websocket.send"方法，浏览器就会发现消息发布出去，便会立刻或者一定短时间后（不同浏览器或者浏览器版本可能表现不同）触发onclose函数

后端websocket服务也可能出现异常，连接断开后前端也并没有收到通知，因此需要前端定时发送心跳消息ping，后端收到ping类型的消息，立马返回pong消息，告知前端连接正常。如果一定时间没收到pong消息，就说明连接不正常，前端便会执行重连

为了解决以上两个问题，以前端作为主动方，定时发送ping消息，用于检测玩过和前后端连接问题。一旦发现异常，前端持续执行重连逻辑，直到重连成功
    
    
/*错误处理*/
以通过监听error事件来处理所有错误：
var socket = new WebSocket('ws://websocket.example.com');

socket.onerror = function(error){
    consoe.info(`WebSocket Error ${error}`)
}
    

/*关闭连接*/
要关闭连接，客户机或服务器都应该发送包含操作码"0x8"的数据的控制帧。当接收到这样一个帧时，另一个对等点发送一个关闭帧作为响应，然后第一个对等点关闭连接，关闭连接后接收到的任何其他数据都将被丢弃

if(socket.readyState === WebSocket.OPEN){
    socket.close();
}
    
    
    
    
    
    
    
    










