/*介绍*/
	1.内存泄露是每个开发者最终都不得不面对的问题。即便使用自动内存管理的语言，你还是会碰到一些内存泄漏的情况。
	2.内存泄露会导致一系列问题，比如：运行缓慢，崩溃，高延迟，甚至一些与其他应用相关的问题。

/*什么是内存泄漏*/
	1.本质上来讲，内存泄露是当一块内存不再被应用程序使用的时候，由于某种原因，这块内存没有返还给操作系统或者空闲内存池的现象。
	2.编程语言使用不同的方式来管理内存。这些方式可能会减少内存泄露的机会。
	3.然而，某一块具体的内存是否被使用实际上是一个不可判定问题（undecidable problem）。
	4.换句话说，只有开发者可以搞清楚一块内存是否应该被操作系统回收。某些编程语言提供了帮助开发者来处理这件事情的特性。而其它的编程语言需要开发者明确知道内存的使用情况。
	5.维基百科上有几篇写的不错的讲述手动 和自动内存管理的文章。

/*Javascript 的内存管理*/
	1.Javascript 是那些被称作垃圾回收语言当中的一员。
	2.垃圾回收语言通过周期性地检查那些之前被分配出去的内存是否可以从应用的其他部分访问来帮助开发者管理内存。
	3.换句话说，垃圾回收语言将内存管理的问题从
		"什么样的内存是仍然被使用的" 简化成为
		"什么样的内存仍然可以从应用程序的其他部分访问"。
		两者的区别是细微的，但是很重要：开发者只需要知道一块已分配的内存是否会在将来被使用，而不可访问的内存可以通过算法确定并标记以便返还给操作系统。

/*垃圾收集器 Mark-and-sweep*/
	大多数的垃圾收集器（简称 GC）使用一个叫做"mark-and-sweep"的算法。这个算法由以下的几个步骤组成：

	1.垃圾收集器建立了一个"根节点"列表。根节点通常是那些引用被保留在代码中的全局变量。
	2.对于 Javascript 而言，“Window” 对象就是一个能作为根节点的全局变量例子。window 对象是一直都存在的（即：不是垃圾）。所有根节点都是检查过的并且被标记为活动的（即：不是垃圾）。所有的子节点也都被递归地检查过。每块可以从根节点访问的内存都不会被视为垃圾。 所有没有被标记为垃圾的内存现在可以被当做垃圾，而垃圾收集器也可以释放这些内存并将它们返还给操作系统。
	3.现代垃圾收集器使用不同的方式来改进这些算法，但是它们都有相同的本质：可以访问的内存块被标记为非垃圾而其余的就被视为垃圾。
	4.不必要的引用就是那些程序员知道这块内存已经没用了，但是出于某种原因这块内存依然存在于活跃的根节点发出的节点树中。在 Javascript 的环境中，不必要的引用是某些不再被使用的代码中的变量。这些变量指向了一块本来可以被释放的内存。一些人认为这是程序员的失误。

	所以想要理解什么是 Javascript 中最常见的内存泄露，我们需要知道在什么情况下会出现不必要的引用。

/*垃圾收集器的直观行为*/
	尽管垃圾收集器是便利的，但是使用它们也需要有一些利弊权衡。其中之一就是不确定性。
	也就是说，GC 的行为是不可预测的。通常情况下都不能确定什么时候会发生垃圾回收。
	这意味着在一些情形下，程序会使用比实际需要更多的内存。
	有些的情况下，在很敏感的应用中可以观察到明显的卡顿。尽管不确定性意味着你无法确定什么时候垃圾回收会发生，不过绝大多数的 GC 实现都会在内存分配时遵从通用的垃圾回收过程模式。如果没有内存分配发生，大部分的 GC 都会保持静默。考虑以下的情形：

	1.大量内存分配发生时。
	2.大部分（或者全部）的元素都被标记为不可达（假设我们讲一个指向无用缓存的引用置 null 的时候）。
	3.没有进一步的内存分配发生。

	这个情形下，GC 将不会运行任何进一步的回收过程。也就是说，尽管有不可达的引用可以触发回收，但是收集器并不要求回收它们。严格的说这些不是内存泄露，但仍然导致高于正常情况的内存空间使用。


/*事例1*/
	import demo1 from './demo1.js';

/*事例2*/
	import demo2 from './demo2.js';

/*事例3*/
	import demo3 from './demo3.js';

/*事例4*/
	import demo4 from './demo4.js';
