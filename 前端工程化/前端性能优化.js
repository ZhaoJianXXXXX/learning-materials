1.css方面
	(1)如果某个样式是通过重排得到的，那么最好缓存结果。避免下一次用到的时候，浏览器又要重排；接口请求也如此(享元模式)
	(2)不要一条条地改变样式，而要通过改变class，或者csstext属性，一次性地改变样式
	(3)先将元素设为display:none（需要1次重排和重绘），然后对这个节点进行100次操作，最后再恢复显示（需要1次重排和重绘）。2次渲染，取代了可能高达100次的重新渲染
	(4)position属性为absolute或fixed的元素，重排的开销会比较小，因为不用考虑它对其他元素的影响。
	(5)只在必要的时候，才将元素的display属性为可见，因为不可见的元素不影响重排和重绘。另外，visibility:hidden的元素只对重绘有影响，不影响重排
	(6)渲染动画可以开启GPU加速(通过-webkit-transform:transition3d/translateZ开启GPU硬件加速之后,些时候可能会导致浏览器频繁闪烁或抖动，可以尝试以下办法解决之：-webkit-backface-visibility:hidden;-webkit-perspective:1000;)
	(7)图片压缩 css文件模块化
2.js方面
	(1)读写分离，DOM的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作
	(2)尽量使用离线DOM，而不是真实的网面DOM，来改变元素样式。比如，操作Document Fragment对象，完成后再把这个对象加入DOM。再比如，使用 cloneNode() 方法，在克隆的节点上进行操作，然后再用克隆的节点替换原始节点(已经有种虚拟DOM的感觉)
	(3)使用"window.requestAnimationFrame()"、"window.requestIdleCallback()"这两个方法调节重新渲染
	(4)灵活运用缓存技术 cookie sessionStorage localStorage
	(5)减少请求数量
	(6)合理使用 闭包函数(包括柯里化函数) 防抖函数 节流函数 分时函数 事件委托...
	(7)合理使用设计模式 工厂模式 策略模式 享元模式 职责链模式 中介者模式 代理模式 观察者模式...
	(8)图片懒加载，瀑布流
	(9)防止意外的内存泄漏(意外的全局变量 没有清空的监听事件与定时器事件 没有清空无效的DOM引用 没有及时清空闭包函数)
	(10)代码压缩
	(11)按需加载 js文件模块化 公共js文件公共化(vendor.js)
	(12)使用虚拟DOM的脚本库，比如React等。
3.后端方面
	(1)优化查询
	(2)后端提高代码质量...
4.产品方面
	(1)页面功能目的性提高，功能单一化，减少请求与渲染
	(2)总而言之产品经理素质提高...
